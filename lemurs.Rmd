---
title: "I like to move it, move it: Keeping lemurs happy with R"
author: Dr. Ludmilla Figueiredo
output: 
  html_document:
    code_folding: hide
---

Here, we are going to use the [Lemurs](https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-08-24/readme.md) data set provided by the [TidyTuesday project](https://github.com/rfordatascience/tidytuesday) to illustrate:

+ data processing with packages from the [R Tidyverse](https://www.tidyverse.org)
+ document your with RMarkdown and the [minimal set up for reproducible research](https://github.com/ludmillafigueiredo/computational_notebooks) I propose for beginners


# Packages and basic set up

## R packages

In this analysis, we will rely heavily on packages from the [Tidyverse](https://www.tidyverse.org).
This is a collection of packages that were collectively designed specifically for data science.
This means that these packages share data structures, function syntax, and can be easily combined in a slick, yet comprehensible workflow. 
```{r message==FALSE}
library(tidyverse)
```
More specifically, we will work with the following packages:

+ `readr`: functions to easily, yet reliably read in rectangular data (e.g. csv, tsv) containing multiple data types (e.g. numeric, logical). 
By reliably, I mean that it can recognize errors in that table formatting that require checking by the user (e.g. the occurrence of numeric values in a seemingly logical column). 

+ `tidyr`: functions to create and manipulate "tidy data", i.e., data where each column is a variable, each row is an observation, and each is unique.
The other functions in `tidyverse` are optimized to work with this type of data.

+ `dplyr`: functions for data manipulation (e.g. filtering, summarizing).
One of features that make this package particularly good is the fact that functions are names as verbs, indicating the type of data transformation that it does.
This makes reading the code considerably easy.

+ `gglot2`: functions to code graphs following the ("Grammar of Graphics")[https://cfss.uchicago.edu/notes/grammar-of-graphics/].
Simply put, the grammar of graphics is a system of rules that allows coding data into visual elements - reading the article above and other precise definitions is highly recommendable, though.

## Project set up

The files in this project are organized as such:
```{markdown}
data_crunch_wue
|--README.md
|--lemurs.Rmd
|--figures
|--results
|  |--data
|  |  |--processed 
|  |  |--processed
|  |--figures
|  |--tables
|  |--scripts
```

This file structure adapts the [minimal set up](https://github.com/ludmillafigueiredo/computational_notebooks) I propose for scientific computational projects. 
The idea is organizing the project around the `.Rmd` file (the `.html` version of which you are reading right now).
By combining descriptive text code and results of the analysis, this "computational notebook" facilitates communication and reproducibility of the work it reports.
As part of this set up, inputs and outputs can be accessed with relative paths: 
```{r}
processed_dir <- file.path("results", "data", "raw")
processed_dir <- file.path("results", "data", "processed")
scripts_dir <- file.path("reults", "scripts")
figures_dir <- file.path("results", "figures")
tables_dir <- file.path("results", "tables")
```


# Original data

As shown in the [dataset page](https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-08-24/readme.md), the original data can be downloaded the git repository:

```{r}
lemurs_df <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-08-24/lemur_data.csv')
```
Already at loading, it seems we come across a parsing error: `read_csv` identified the column `age_of_living_y` as containing characters of type `logical` (it cites the expected values as ``1/0/T/F/TRUE/FALSE`), but it seems that at line 1324, the value is a `double`. 
The simplest reason why this error can occur is that, with default settings, the `read_csv` function identifies the types of objects (`character`, `logical`, etc.) in each column of the data frame based on the first 1000 rows. We can verify whether the contents of the first 1000 rows:

```{r}
unique(lemurs.df[1:1000, "age_of_living_y"])
```

Thus, we see that missing data in these rows lead to the issue with its identification. 
We can fix it by explicitly identifying the types of objects in the columns of the data frame.
Before we do this, however, let's verify that `age_of_living_y` was the only column that raised an issue, with the `problems` attribute of objects read with the `read_*` functions from the `readr` package. 
This attribute stores parsing problems in a data frame containing the `row` and `col` where `expected` and `actual` values differ.

```{r}
unique(problems(lemurs.df)$col)
```

When specifying the columns types, it's all or nothing: we either identify all of them, or none at all.
Luckily for us, the `spec()` function lists all column types, and we just need to fixed the ones that were read in wrong.

```{r}
spec(lemurs.df)
```

```{r}
lemurs_rawdf <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-08-24/lemur_data.csv',
                          col_types = cols(
                            .default = col_double(),
                            taxon = col_character(),
                            dlc_id = col_character(),
                            hybrid = col_character(),
                            sex = col_character(),
                            name = col_character(),
                            current_resident = col_character(),
                            stud_book = col_character(),
                            dob = col_date(format = ""),
                            birth_month = col_double(),
                            estimated_dob = col_character(),
                            birth_type = col_character(),
                            birth_institution = col_character(),
                            estimated_concep = col_date(format = ""),
                            dam_id = col_character(),
                            dam_name = col_character(),
                            dam_taxon = col_character(),
                            dam_dob = col_date(format = ""),
                            dam_age_at_concep_y = col_double(),
                            sire_id = col_character(),
                            sire_name = col_character(),
                            sire_taxon = col_character(),
                            sire_dob = col_date(format = ""),
                            dod = col_date(format = ""),
                            age_of_living_y = col_double(), ## the column that was tyoed wrong by default
                            dob_estimated = col_character(),
                            weight_date = col_date(format = ""),
                            age_category = col_character(),
                            preg_status = col_character(),
                            concep_date_if_preg = col_date(format = ""),
                            infant_dob_if_preg = col_date(format = "")
                            )
)
```
Let's also load a data frame with the species full names and abbreviations, to use later for more understandable graphs and tables: 
```{r}
lemurs_sppnames_df <- readr::read_csv("https://raw.githubusercontent.com/ludmillafigueiredo/computational_notebooks/master/examples/datastudy_r/results/data/raw/lemurs_sppnames.csv")
```

## Pre-processing

We have a couple of things to work on in the original table, to make it originally more digestible:

1. The individuals names are capitalized, but it can be annoying to read. Let's capitalize the first letter, only.
```{r}
lemurs_smallts <- dplyr::mutate_at(lemurs_rawdf, vars(name, dam_name, sire_name), stringr::str_to_title)
```
2. One of the most notable features of this data set is that it started being collected in the 1960's. However, at first glance, there is no clear column stating the date at which the data was collected (I myself expected it to be one of the first columns).
After reading the data description in the original repo, we learn that the `weight_date` and `month_of_weight` variables report the full date and the month when the weight was measured, respectively. It would be good to have those two easily accessible.
```{r}
lemurs_smallts <- dplyr::mutate(lemurs_smallts, year = lubridate::year(weight_date))
lemurs_smallts <- dplyr::rename(lemurs_smallts, month = month_of_weight)
```
3. In total, 52 variables describing each individual are available in this data set. To start processing it, we do not need all of those, so let's select the ones that are more relevant (chosen based on the column description). Also, we want to simplify some of the columns names.
```{r}
lemurs_smallts <- dplyr::select(lemurs_smallts,
                                c(year, month_of_weight, ## time variables
                                  taxon, dlc_id, ## id variables
                                  hybrid, sex, name, birth_month, litter_size, concep_month, ## birth variables
                                  dam_id, dam_name, dam_taxon, ## name of mother
                                  sire_id, sire_name, sire_taxon, ## name of father
                                  age_at_death_y, age_of_living_y, age_last_verified_y, ## age variables
                                  age_max_live_or_dead_y, age_at_wt_y, age_category, ## age variables
                                  weight_g, avg_daily_wt_change_g, ## weight variables
                                  preg_status, 
                                  n_known_offspring, infant_lit_sz_if_preg))

lemurs_smallts <- dplyr::rename(lemurs_smallts,
                                weight = weight_g,
                                avg_d_wt_chg = avg_daily_wt_change_g,
                                n_offspring = n_known_offspring)
```
4. Finally, let's add the species full names to the data frame
```{r}
lemurs_smallts <- dplyr::right_join(lemurs_sppnames_df, lemurs_smallts, by = "taxon")
```

However, having that many iterations redefining the same object (the `lemurs_smallts` in this case) is not good practice, because if you forget one of them for some reason, it can lead to errors down the line (e.g. you do transformations on one of the "intermediate" stages). Having multiple objects is also not great, because one would have to name them, and it would be a waste of creativity on temporary files.

With that in mind, let's try some *true magic*: We will put all the transformations together in a **pipeline**, where the transformations are chained in a readable form, any only one data frame is created at the end:
```{r}
lemurs_smallts <- lemurs_rawdf %>%
  # 1. capitalizing the first letter, only
  dplyr::mutate_at(vars(name, dam_name, sire_name), stringr::str_to_title) %>%
  # 2. extract the year of the measure, and give a simpler name to the column containing the 
  dplyr::mutate(year = lubridate::year(weight_date)) %>%
  dplyr::rename(month = month_of_weight) %>%
  # 3. select the most relevant 
  dplyr::select(c(year, month, ## time variables
                  taxon, dlc_id, ## id variables
                  hybrid, sex, name, birth_month, litter_size, concep_month, ## birth variables
                  dam_id, dam_name, dam_taxon, ## name of mother
                  sire_id, sire_name, sire_taxon, ## name of father
                  age_at_death_y, age_of_living_y, age_last_verified_y, ## age variables
                  age_max_live_or_dead_y, age_at_wt_y, age_category, ## age variables
                  weight_g, avg_daily_wt_change_g, ## weight variables
                  preg_status, 
                  n_known_offspring, infant_lit_sz_if_preg)) %>%
  ## simplify the names
  dplyr::rename(weight = weight_g,
                avg_d_wt_chg = avg_daily_wt_change_g,
                n_offspring = n_known_offspring) %>%
  # 4. add species full names
  dplyr::right_join(lemurs_sppnames_df,., by = "taxon") ## id species
```

# Exploring the data

## Reproduction

If we are trying to protect a species, reproduction is one of the most important aspects to understand.
With the DLC lemur data, we can estimate fertility rates, reproductive seasons, and the relationship between age, sizes and offspring production.

### Fertility rates per taxon

TODO: mean and sd number of offspring (measured from litter size, n_offspring, or infant_lt_sz) per female
```{r}
lemurs_smallts %>%
  dplyr::filter(!is.na(infant_lit_sz_if_preg)) %>%
  dplyr::group_by(dlc_id, taxon) %>%
  dplyr::summarize(inflt_mean_ind = mean(infant_lit_sz_if_preg)) %>%
  ungroup() %>%
  dplyr::group_by(taxon) %>%
  dplyr::summarize(inflt_mean = mean(inflt_mean_ind),
                   inflt_sd = sd(inflt_mean_ind),
                   n = n())
```

## Main text figures/tables

## Seasonality of species
TODO: facetted plot of mean and sd number of births for seasonal species
```{r}
births_df <- lemurs_smallts %>%
  dplyr::select(dlc_id, taxon, birth_month) %>%
  dplyr::filter(!is.na(birth_month)) %>%
  dplyr::mutate_at(vars(birth_month), 
                   lubridate::month, label = TRUE, 
                   locale = Sys.getlocale(category = "LC_CTYPE")) %>% ## id months
  dplyr::right_join(lemurs_sppnames_df,., by = "taxon") %>% ## id species
  dplyr::arrange(taxon, birth_month) 
 
months_fct <- lubridate::month(1:12, label = TRUE, locale = Sys.getlocale(category = "LC_CTYPE"))

birth_season_countdf <- births_df %>%
  unique() %>%
  dplyr::group_by(species, common_name, taxon, birth_month) %>%
  dplyr::summarize(n_births = n()) %>%
  ungroup() %>%
  dplyr::arrange(species, common_name, taxon, birth_month) %>%
  tidyr::pivot_wider(id_cols = c(species, common_name, taxon), 
                     names_from = birth_month, values_from = n_births) %>%
  tidyr::pivot_longer(all_of(months_fct), 
                      names_to = "birth_month", values_to = "n_births")%>%
  ## because strings can't be converted back to months, the following turns out quite cumbersome
  dplyr::mutate_at(vars(birth_month), 
                   ~ ordered(.,
                             levels = all_of(months_fct)) %>%
                     as.numeric) %>%
  dplyr::mutate_at(vars(birth_month), 
                   lubridate::month, label = TRUE,
                                       locale = Sys.getlocale(category = "LC_CTYPE")) %>%
  dplyr::arrange(taxon, birth_month) 
```

```{r}
births_df  %>%
  ggplot(aes(x = birth_month, y = species, fill = species)) +
  geom_density_ridges(alpha=0.6, stat = ) + 
  ##scale_fill_continuous() +
  theme_minimal() + 
  labs(x = "Month", y = "Species") +
  theme(legend.position = "none")
```

```{r}
births_df  %>%
  ggplot(aes(x = birth_month, fill = species)) +
  geom_bar(alpha=0.6, stat = "count") + 
  theme_minimal() + 
  facet_wrap(~species) +
  labs(x = "Month", y = "Species") +
  theme(legend.position = "none")
```
Doesn't look that good.

# Offspring production
```{r}
offspring_df <- lemurs_smallts %>%
  dplyr::select(year, month, species, taxon, dlc_id, sex,
                litter_size, ## size of litter it was born into
                age_at_wt_y, weight, 
                preg_status, 
                n_offspring, ## total number of offspring produced until that day
                infant_lit_sz_if_preg)
```

## individual weight vs. litter
TODO: get minimal weight of each individual (or weight at minimal age), and plot it against against the litter it came from (color males and females differently)
```{r}
litterweight_df <- offspring_df %>%
  dplyr::group_by(dlc_id) %>%
  dplyr::filter(weight == min(weight)) %>%
  ungroup()

litterweight_df %>%
  dplyr::group_by(species) %>%
  dplyr::summarize(weight_mean = mean(weight),
                   weight_sd = sd(weight))
```

```{r}
litterweight_df  %>%
  dplyr::filter(sex != "ND") %>%
  ggplot(aes(x = litter_size, y = weight, colour = species, fill = species, group = species))+
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~sex, ncol = 1) +
  theme_minimal() +
  theme(legend.position = "none")
```
TODO: slide do master tem codigo pra diferenciar entre o q ta acontecendo com machos e o q ta acontecendo com femeas

## individual weight vs. offspring production
get weight of each pregnant individual, and plot it against against the n_offspring it produced
```{r}
offspring_df  %>%
  dplyr::filter(preg_status == "P") %>%
  ggplot(aes(y = infant_lit_sz_if_preg, x = weight, colour = species))+
  geom_point(alpha = 0.5) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
offspring_df  %>%
  dplyr::filter(preg_status == "P") %>%
  ggplot(aes(y = infant_lit_sz_if_preg, x = weight, colour = species))+
  geom_point(alpha = 0.5) +
  geom_smooth(method = lm) +
  theme_minimal() +
  theme(legend.position = "none")
```

TODO: get weight of each individual at its oldest, and plot it against the n_offspring it produced. Facet for males and females
```{r}
offspring_df  %>%
  filter(sex != "ND") %>%
  dplyr::group_by(dlc_id) %>%
  dplyr::filter(age_at_wt_y == max(age_at_wt_y)) %>%
  ggplot(aes(y = n_offspring, x = weight, colour = species))+
  geom_point(alpha = 0.5) +
  facet_wrap(~sex, ncol = 1) +
  theme_minimal() +
  theme(legend.position = "none")
```


```{r}
offspring_df  %>%
  filter(sex != "ND") %>%
  dplyr::group_by(dlc_id) %>%
  dplyr::filter(age_at_wt_y == max(age_at_wt_y)) %>%
  ggplot(aes(y = n_offspring, x = weight, colour = species))+
  geom_point(alpha = 0.5) +
  geom_smooth(method = lm) +
  facet_wrap(~sex, ncol = 1) +
  theme_minimal() +
  theme(legend.position = "none")
```

## Size difference between sexes

```{r}
offspring_df  %>%
  filter(sex != "ND", preg_status == "NP") %>%
  ggplot(aes(x = sex, y = weight, colour = species))+
  geom_point(alpha = 0.5) +
  theme_minimal() +
  theme(legend.position = "none")
```



# Next steps

Try exploring the `flights` data set, included with the basic R download.
```{r}
install.packages("nycfilghts13")
```
```{r}
library(nycflights13)
```

*R version, the OS and attached or loaded packages:*
<!-- Leave this so people know the software they need to reproduce your work. -->
```{r}
sessionInfo()
```
